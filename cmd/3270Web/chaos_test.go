package main

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/jnnngs/3270Web/internal/host"
	"github.com/jnnngs/3270Web/internal/session"
)

// buildSampleApp1Screen returns a mock 3270 screen that resembles SampleApp1
// (a name-entry and validation form). It has protected label fields and three
// unprotected input fields (first name, last name, password), mirroring the
// real app1 layout used by the go3270 sample application.
func buildSampleApp1Screen() *host.Screen {
	s := &host.Screen{
		Width:       80,
		Height:      24,
		IsFormatted: true,
		Buffer:      make([][]rune, 24),
	}
	for i := range s.Buffer {
		s.Buffer[i] = make([]rune, 80)
	}
	// Protected label: "First Name:" at row 3, cols 0-10
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 3, 10, 3, 0, 0))
	// Unprotected input for first name at row 3, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 3, 30, 3, 0, 0))
	// Protected label: "Last Name:" at row 5, cols 0-9
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 5, 9, 5, 0, 0))
	// Unprotected input for last name at row 5, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 5, 30, 5, 0, 0))
	// Protected label: "Password:" at row 7, cols 0-8
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 7, 8, 7, 0, 0))
	// Unprotected input for password at row 7, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 7, 30, 7, 0, 0))
	return s
}

// buildSampleApp2Screen returns a mock 3270 screen that resembles SampleApp2
// (an RSS newsreader). Most of the screen is protected content (headlines) with
// a single unprotected selection/navigation field, reflecting the real app2
// layout generated by the go3270 newsreader.
func buildSampleApp2Screen() *host.Screen {
	s := &host.Screen{
		Width:       80,
		Height:      24,
		IsFormatted: true,
		Buffer:      make([][]rune, 24),
	}
	for i := range s.Buffer {
		s.Buffer[i] = make([]rune, 80)
	}
	// Protected header row (title bar) at row 0
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 0, 79, 0, 0, 0))
	// Protected news headline rows (rows 2, 4, 6, 8, 10, 12, 14, 16, 18)
	for row := 2; row <= 18; row += 2 {
		s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, row, 79, row, 0, 0))
	}
	// Unprotected selection/navigation input at row 20, cols 0-4
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 0, 20, 4, 20, 0, 0))
	return s
}

// setupChaosTestApp creates a minimal App with a pre-seeded session and a Gin
// router that exposes only the chaos endpoints. It mirrors the pattern used
// throughout main_test.go (no CSRF middleware, gin.TestMode, httptest).
// It returns the App, the router, and the session cookie value to pass in
// requests via the "3270Web_session" cookie.
func setupChaosTestApp(t *testing.T, mockHost *host.MockHost) (*App, *gin.Engine, string) {
	t.Helper()
	gin.SetMode(gin.TestMode)

	mgr := session.NewManager()
	sess := mgr.CreateSession(mockHost)
	sess.TargetHost = "127.0.0.1"
	sess.TargetPort = 3270

	app := &App{
		SessionManager: mgr,
		chaosEngines:   newChaosEngineStore(),
	}

	r := gin.New()
	r.POST("/chaos/start", app.ChaosStartHandler)
	r.POST("/chaos/stop", app.ChaosStopHandler)
	r.POST("/chaos/remove", app.ChaosRemoveHandler)
	r.GET("/chaos/status", app.ChaosStatusHandler)
	r.POST("/chaos/export", app.ChaosExportHandler)

	return app, r, sess.ID
}

// chaosRequest is a small helper that fires an HTTP request against the test
// router, attaches the session cookie, and returns the recorder.
func chaosRequest(r *gin.Engine, method, path string, body []byte, sessID string) *httptest.ResponseRecorder {
	var req *http.Request
	if body != nil {
		req = httptest.NewRequest(method, path, bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
	} else {
		req = httptest.NewRequest(method, path, nil)
	}
	req.AddCookie(&http.Cookie{Name: "3270Web_session", Value: sessID})
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)
	return w
}

// runChaosExplorerScenarios exercises the four chaos-explorer scenarios defined
// in the problem statement for any sample-app mock screen:
//
//  1. Start chaos exploration from the toolbar (POST /chaos/start).
//  2. Verify status shows running – active indicator visible, stepsRun and
//     transitions fields present and incrementing.
//  3. Export the workflow JSON and confirm it is well-formed JSON.
//  4. Stop chaos exploration (POST /chaos/stop).
//
// The engine is started with maxSteps=0 (unlimited) and a short step delay so
// that it is still active when status and export are checked, making the test
// deterministic on any CI runner.
func runChaosExplorerScenarios(t *testing.T, screen *host.Screen, label string) {
	t.Helper()

	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("[%s] failed to create mock host: %v", label, err)
	}
	mockHost.Screen = screen
	mockHost.Connected = true

	app, r, sessID := setupChaosTestApp(t, mockHost)

	// ── 1. Start chaos exploration ──────────────────────────────────────────
	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":       0, // unlimited – stopped manually after assertions
		"timeBudgetSec":  30,
		"stepDelaySec":   0.05, // 50 ms per step keeps the test fast
		"seed":           42,   // deterministic replay
		"maxFieldLength": 8,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/start: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var startResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &startResp); err != nil {
		t.Fatalf("[%s] start response not valid JSON: %v", label, err)
	}
	if startResp["status"] != "started" {
		t.Errorf("[%s] start: want status=started, got %v", label, startResp["status"])
	}

	// ── 2. Verify status shows running ──────────────────────────────────────
	// Poll until active=true (engine goroutine may not have set the flag yet).
	var statusResp map[string]interface{}
	deadline := time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if w.Code != http.StatusOK {
			t.Fatalf("[%s] GET /chaos/status: want 200, got %d", label, w.Code)
		}
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			t.Fatalf("[%s] status response not valid JSON: %v", label, err)
		}
		if active, _ := statusResp["active"].(bool); active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	if active, _ := statusResp["active"].(bool); !active {
		t.Errorf("[%s] status: want active=true, got %v", label, statusResp["active"])
	}
	if _, ok := statusResp["stepsRun"]; !ok {
		t.Errorf("[%s] status response missing stepsRun field", label)
	}
	if _, ok := statusResp["transitions"]; !ok {
		t.Errorf("[%s] status response missing transitions field", label)
	}

	// Poll until at least one step has been recorded (indicator incrementing).
	deadline = time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			break
		}
		if steps, _ := statusResp["stepsRun"].(float64); steps > 0 {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}
	if steps, _ := statusResp["stepsRun"].(float64); steps == 0 {
		t.Errorf("[%s] status: stepsRun never incremented above 0", label)
	}

	// ── 3. Export workflow and validate well-formed JSON ─────────────────────
	// Called while the engine is still running so the engine entry remains in
	// the store (syncChaosStatus only removes it once active=false).
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/export: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var exportedWorkflow interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &exportedWorkflow); err != nil {
		t.Fatalf("[%s] exported workflow is not valid JSON: %v", label, err)
	}
	if exportedWorkflow == nil {
		t.Errorf("[%s] exported workflow JSON must not be null", label)
	}

	// ── 4. Stop chaos exploration ─────────────────────────────────────────────
	w = chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/stop: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var stopResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &stopResp); err != nil {
		t.Fatalf("[%s] stop response not valid JSON: %v", label, err)
	}
	if st := stopResp["status"]; st != "stopping" && st != "not running" {
		t.Errorf("[%s] stop: unexpected status %q", label, st)
	}

	// Confirm engine is no longer active after stop (optional: wait for goroutine).
	deadline = time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		if eng, ok := app.chaosEngines.get(sessID); !ok || !eng.Status().Active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}
	if eng, ok := app.chaosEngines.get(sessID); ok && eng.Status().Active {
		t.Errorf("[%s] engine still active after stop", label)
	}
}

// TestChaosExplorer_SampleApp1 validates all four chaos-explorer scenarios
// against a mock screen representing SampleApp1 (name-entry form).
func TestChaosExplorer_SampleApp1(t *testing.T) {
	runChaosExplorerScenarios(t, buildSampleApp1Screen(), "SampleApp1")
}

// TestChaosExplorer_SampleApp2 validates all four chaos-explorer scenarios
// against a mock screen representing SampleApp2 (RSS newsreader).
func TestChaosExplorer_SampleApp2(t *testing.T) {
	runChaosExplorerScenarios(t, buildSampleApp2Screen(), "SampleApp2")
}

// TestChaosStart_DoubleStart ensures that starting chaos when it is already
// running returns HTTP 409 Conflict (matching the data-chaos-start selector
// being disabled in the UI when active).
func TestChaosStart_DoubleStart(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	payload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     0,
		"stepDelaySec": 0.05,
		"seed":         1,
	})

	// First start – must succeed.
	w := chaosRequest(r, http.MethodPost, "/chaos/start", payload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("first start: want 200, got %d", w.Code)
	}

	// Poll until engine is active.
	deadline := time.Now().Add(2 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		var sr map[string]interface{}
		json.Unmarshal(w.Body.Bytes(), &sr) //nolint:errcheck
		if active, _ := sr["active"].(bool); active {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}

	// Second start – must return 409.
	w = chaosRequest(r, http.MethodPost, "/chaos/start", payload, sessID)
	if w.Code != http.StatusConflict {
		t.Errorf("double start: want 409, got %d – body: %s", w.Code, w.Body.String())
	}

	// Clean up.
	chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID) //nolint:errcheck
}

// TestChaosStop_WhenNotRunning ensures that stopping when no engine is active
// returns HTTP 200 with status "not running" (matching the data-chaos-stop
// hidden-by-default behaviour in the UI).
func TestChaosStop_WhenNotRunning(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("stop when not running: want 200, got %d", w.Code)
	}
	var resp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &resp); err != nil {
		t.Fatalf("stop response not valid JSON: %v", err)
	}
	if resp["status"] != "not running" {
		t.Errorf("want status=not running, got %q", resp["status"])
	}
}

// TestChaosExport_WithoutEngine ensures that calling export before starting
// chaos returns HTTP 404 (matching the data-chaos-export hidden-by-default
// behaviour in the UI – the button is only shown after a run).
func TestChaosExport_WithoutEngine(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusNotFound {
		t.Errorf("export without engine: want 404, got %d – body: %s", w.Code, w.Body.String())
	}
}

// TestChaosExport_AfterCompletion verifies that export remains available after
// a chaos run has completed and its engine has been removed from the store.
func TestChaosExport_AfterCompletion(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     2,
		"stepDelaySec": 0,
		"seed":         123,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d – body: %s", w.Code, w.Body.String())
	}

	// Wait for the engine to complete and be removed by syncChaosStatus.
	deadline := time.Now().Add(6 * time.Second)
	for time.Now().Before(deadline) {
		if _, ok := app.chaosEngines.get(sessID); !ok {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}
	if _, ok := app.chaosEngines.get(sessID); ok {
		t.Fatal("expected chaos engine to be removed after completion")
	}

	// Status should still include saved run details.
	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("status: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var statusResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
		t.Fatalf("status response not valid JSON: %v", err)
	}
	if got, _ := statusResp["stepsRun"].(float64); got < 1 {
		t.Fatalf("status stepsRun = %v, want > 0", statusResp["stepsRun"])
	}
	runID, _ := statusResp["loadedRunID"].(string)
	if runID == "" {
		t.Fatalf("status loadedRunID = %q, want non-empty", runID)
	}

	// Export should succeed from saved run data, even without a live engine.
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("export after completion: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var exported WorkflowConfig
	if err := json.Unmarshal(w.Body.Bytes(), &exported); err != nil {
		t.Fatalf("exported workflow is not valid JSON: %v", err)
	}
	if len(exported.Steps) == 0 {
		t.Fatal("exported workflow contains no steps")
	}
}

// TestChaosExport_AfterCompletion_FallbackFromDisk verifies export still works
// if in-memory loaded run state is missing but the completed run was saved.
func TestChaosExport_AfterCompletion_FallbackFromDisk(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     2,
		"stepDelaySec": 0,
		"seed":         456,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d – body: %s", w.Code, w.Body.String())
	}

	// Wait until status reports completion and includes loadedRunID.
	var statusResp map[string]interface{}
	var runID string
	deadline := time.Now().Add(6 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if w.Code != http.StatusOK {
			t.Fatalf("status: want 200, got %d – body: %s", w.Code, w.Body.String())
		}
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			t.Fatalf("status response not valid JSON: %v", err)
		}
		active, _ := statusResp["active"].(bool)
		runID, _ = statusResp["loadedRunID"].(string)
		if !active && runID != "" {
			break
		}
		time.Sleep(25 * time.Millisecond)
	}
	if runID == "" {
		t.Fatal("expected completed runID in status")
	}

	// Simulate lost in-memory run cache for this session.
	app.chaosEngines.mu.Lock()
	delete(app.chaosEngines.loadedRuns, sessID)
	app.chaosEngines.mu.Unlock()

	// Export must recover from disk via session loadedRunID.
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("export fallback: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var exported WorkflowConfig
	if err := json.Unmarshal(w.Body.Bytes(), &exported); err != nil {
		t.Fatalf("exported workflow is not valid JSON: %v", err)
	}
	if len(exported.Steps) == 0 {
		t.Fatal("exported workflow contains no steps")
	}
}

// TestChaosStatus_NoSession verifies that requests without a valid session
// cookie return HTTP 401, exercising the data-chaos-indicator hidden path.
func TestChaosStatus_NoSession(t *testing.T) {
	gin.SetMode(gin.TestMode)

	mgr := session.NewManager()
	app := &App{
		SessionManager: mgr,
		chaosEngines:   newChaosEngineStore(),
	}
	r := gin.New()
	r.GET("/chaos/status", app.ChaosStatusHandler)

	req := httptest.NewRequest(http.MethodGet, "/chaos/status", nil)
	// No session cookie attached.
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)

	if w.Code != http.StatusUnauthorized {
		t.Errorf("no session: want 401, got %d", w.Code)
	}
}

// setupFullChaosTestApp creates a test App with all chaos routes registered,
// including the persistence routes (/chaos/runs, /chaos/load, /chaos/resume).
// It uses t.TempDir() for the chaosRunsDir so that each test gets an isolated
// directory that is cleaned up automatically.
func setupFullChaosTestApp(t *testing.T, mockHost *host.MockHost) (*App, *gin.Engine, string) {
	t.Helper()
	gin.SetMode(gin.TestMode)

	mgr := session.NewManager()
	sess := mgr.CreateSession(mockHost)
	sess.TargetHost = "127.0.0.1"
	sess.TargetPort = 3270

	app := &App{
		SessionManager: mgr,
		chaosEngines:   newChaosEngineStore(),
		chaosRunsDir:   t.TempDir(),
	}

	r := gin.New()
	r.POST("/chaos/start", app.ChaosStartHandler)
	r.POST("/chaos/stop", app.ChaosStopHandler)
	r.POST("/chaos/remove", app.ChaosRemoveHandler)
	r.GET("/chaos/status", app.ChaosStatusHandler)
	r.POST("/chaos/export", app.ChaosExportHandler)
	r.GET("/chaos/runs", app.ChaosListRunsHandler)
	r.POST("/chaos/load", app.ChaosLoadHandler)
	r.POST("/chaos/resume", app.ChaosResumeHandler)

	return app, r, sess.ID
}

// TestChaosStatus_MetadataFields verifies that the status response includes
// the new metadata fields (uniqueScreens, uniqueInputs) introduced for
// discovery tracking.
func TestChaosStatus_MetadataFields(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     3,
		"stepDelaySec": 0,
		"seed":         10,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d", w.Code)
	}

	// Wait for engine to finish (MaxSteps=3, no delay).
	deadline := time.Now().Add(5 * time.Second)
	var statusResp map[string]interface{}
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		json.Unmarshal(w.Body.Bytes(), &statusResp) //nolint:errcheck
		if active, _ := statusResp["active"].(bool); !active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("status: want 200, got %d", w.Code)
	}
	if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
		t.Fatalf("status not valid JSON: %v", err)
	}
	if _, ok := statusResp["uniqueScreens"]; !ok {
		t.Error("status response missing uniqueScreens field")
	}
	if _, ok := statusResp["uniqueInputs"]; !ok {
		t.Error("status response missing uniqueInputs field")
	}
}

// TestChaosListRuns_Empty verifies that listing runs when the directory is
// empty returns an empty JSON array.
func TestChaosListRuns_Empty(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodGet, "/chaos/runs", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("list runs: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var runs []interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &runs); err != nil {
		t.Fatalf("list runs response not valid JSON: %v", err)
	}
	if len(runs) != 0 {
		t.Errorf("want empty list, got %d entries", len(runs))
	}
}

// TestChaosLoadAndResume verifies the load→resume workflow: a run is saved to
// disk, loaded via POST /chaos/load, and then resumed via POST /chaos/resume.
func TestChaosLoadAndResume(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)

	// ── 1. Run a short chaos exploration so a run is auto-saved. ─────────────
	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     3,
		"stepDelaySec": 0,
		"seed":         20,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d", w.Code)
	}

	// Wait for the engine to finish and the auto-save to happen.
	deadline := time.Now().Add(5 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		var sr map[string]interface{}
		json.Unmarshal(w.Body.Bytes(), &sr) //nolint:errcheck
		if active, _ := sr["active"].(bool); !active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	// Wait a little extra for the syncChaosStatus goroutine to detect
	// engine completion and auto-save (it polls every 500 ms).
	var metas []map[string]interface{}
	saveDeadline := time.Now().Add(3 * time.Second)
	for time.Now().Before(saveDeadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/runs", nil, sessID)
		if w.Code == http.StatusOK {
			json.Unmarshal(w.Body.Bytes(), &metas) //nolint:errcheck
			if len(metas) > 0 {
				break
			}
		}
		time.Sleep(50 * time.Millisecond)
	}

	// ── 2. List saved runs – expect at least one. ──────────────────────────
	if w.Code != http.StatusOK {
		t.Fatalf("list runs: want 200, got %d", w.Code)
	}
	if len(metas) == 0 {
		t.Fatal("expected at least one saved run after exploration")
	}
	runID, _ := metas[0]["id"].(string)
	if runID == "" {
		t.Fatal("saved run missing id field")
	}

	// ── 3. Load the saved run. ─────────────────────────────────────────────
	loadPayload, _ := json.Marshal(map[string]interface{}{"runID": runID})
	w = chaosRequest(r, http.MethodPost, "/chaos/load", loadPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("load: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var loadResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &loadResp); err != nil {
		t.Fatalf("load response not valid JSON: %v", err)
	}
	if loadResp["runID"] != runID {
		t.Errorf("load response runID = %v, want %q", loadResp["runID"], runID)
	}

	// Status should now report loadedRunID even without a running engine.
	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	var statusResp map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &statusResp) //nolint:errcheck
	if statusResp["loadedRunID"] != runID {
		t.Errorf("status loadedRunID = %v, want %q", statusResp["loadedRunID"], runID)
	}

	// ── 4. Resume exploration from the loaded run. ─────────────────────────
	resumePayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     2,
		"stepDelaySec": 0,
		"seed":         99,
	})
	w = chaosRequest(r, http.MethodPost, "/chaos/resume", resumePayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("resume: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var resumeResp map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &resumeResp) //nolint:errcheck
	if resumeResp["status"] != "resumed" {
		t.Errorf("resume response status = %v, want \"resumed\"", resumeResp["status"])
	}
	if resumeResp["loadedRunID"] != runID {
		t.Errorf("resume response loadedRunID = %v, want %q", resumeResp["loadedRunID"], runID)
	}

	// Wait for resumed engine to finish.
	deadline = time.Now().Add(5 * time.Second)
	for time.Now().Before(deadline) {
		if eng, ok := app.chaosEngines.get(sessID); !ok || !eng.Status().Active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	// Status should show loadedRunID from the resumed engine.
	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	json.Unmarshal(w.Body.Bytes(), &statusResp) //nolint:errcheck
	// After the resumed engine finishes, loadedRunID may appear in the loaded
	// run store (set via setLoadedRun) or in the status; either is acceptable.
}

// TestChaosLoad_NotFound verifies that loading a non-existent run ID returns 404.
func TestChaosLoad_NotFound(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	loadPayload, _ := json.Marshal(map[string]interface{}{"runID": "nonexistent-run"})
	w := chaosRequest(r, http.MethodPost, "/chaos/load", loadPayload, sessID)
	if w.Code != http.StatusNotFound {
		t.Errorf("load nonexistent: want 404, got %d – body: %s", w.Code, w.Body.String())
	}
}

// TestChaosResume_WithoutLoad verifies that calling resume before loading a
// run returns HTTP 400.
func TestChaosResume_WithoutLoad(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodPost, "/chaos/resume", nil, sessID)
	if w.Code != http.StatusBadRequest {
		t.Errorf("resume without load: want 400, got %d – body: %s", w.Code, w.Body.String())
	}
}

func TestChaosRemove_AfterCompletion(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     2,
		"stepDelaySec": 0,
		"seed":         777,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d – body: %s", w.Code, w.Body.String())
	}

	// Wait for completed status and loaded run data.
	var statusResp map[string]interface{}
	deadline := time.Now().Add(6 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if w.Code != http.StatusOK {
			t.Fatalf("status: want 200, got %d – body: %s", w.Code, w.Body.String())
		}
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			t.Fatalf("status response not valid JSON: %v", err)
		}
		active, _ := statusResp["active"].(bool)
		stepsRun, _ := statusResp["stepsRun"].(float64)
		runID, _ := statusResp["loadedRunID"].(string)
		if !active && stepsRun > 0 && runID != "" {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	w = chaosRequest(r, http.MethodPost, "/chaos/remove", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("remove: want 200, got %d – body: %s", w.Code, w.Body.String())
	}

	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("status after remove: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	statusResp = map[string]interface{}{}
	if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
		t.Fatalf("status after remove not valid JSON: %v", err)
	}
	if active, _ := statusResp["active"].(bool); active {
		t.Fatalf("status after remove active = true, want false")
	}
	if stepsRun, _ := statusResp["stepsRun"].(float64); stepsRun != 0 {
		t.Fatalf("status after remove stepsRun = %v, want 0", stepsRun)
	}
	if _, ok := statusResp["loadedRunID"]; ok {
		t.Fatalf("status after remove should not include loadedRunID, got %v", statusResp["loadedRunID"])
	}

	// Export should no longer be available for the removed run state.
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusNotFound {
		t.Fatalf("export after remove: want 404, got %d – body: %s", w.Code, w.Body.String())
	}
}
