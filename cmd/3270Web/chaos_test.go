package main

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/jnnngs/3270Web/internal/host"
	"github.com/jnnngs/3270Web/internal/session"
)

// buildSampleApp1Screen returns a mock 3270 screen that resembles SampleApp1
// (a name-entry and validation form). It has protected label fields and three
// unprotected input fields (first name, last name, password), mirroring the
// real app1 layout used by the go3270 sample application.
func buildSampleApp1Screen() *host.Screen {
	s := &host.Screen{
		Width:       80,
		Height:      24,
		IsFormatted: true,
		Buffer:      make([][]rune, 24),
	}
	for i := range s.Buffer {
		s.Buffer[i] = make([]rune, 80)
	}
	// Protected label: "First Name:" at row 3, cols 0-10
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 3, 10, 3, 0, 0))
	// Unprotected input for first name at row 3, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 3, 30, 3, 0, 0))
	// Protected label: "Last Name:" at row 5, cols 0-9
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 5, 9, 5, 0, 0))
	// Unprotected input for last name at row 5, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 5, 30, 5, 0, 0))
	// Protected label: "Password:" at row 7, cols 0-8
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 7, 8, 7, 0, 0))
	// Unprotected input for password at row 7, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 7, 30, 7, 0, 0))
	return s
}

// buildSampleApp2Screen returns a mock 3270 screen that resembles SampleApp2
// (an RSS newsreader). Most of the screen is protected content (headlines) with
// a single unprotected selection/navigation field, reflecting the real app2
// layout generated by the go3270 newsreader.
func buildSampleApp2Screen() *host.Screen {
	s := &host.Screen{
		Width:       80,
		Height:      24,
		IsFormatted: true,
		Buffer:      make([][]rune, 24),
	}
	for i := range s.Buffer {
		s.Buffer[i] = make([]rune, 80)
	}
	// Protected header row (title bar) at row 0
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 0, 79, 0, 0, 0))
	// Protected news headline rows (rows 2, 4, 6, 8, 10, 12, 14, 16, 18)
	for row := 2; row <= 18; row += 2 {
		s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, row, 79, row, 0, 0))
	}
	// Unprotected selection/navigation input at row 20, cols 0-4
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 0, 20, 4, 20, 0, 0))
	return s
}

// setupChaosTestApp creates a minimal App with a pre-seeded session and a Gin
// router that exposes only the chaos endpoints. It mirrors the pattern used
// throughout main_test.go (no CSRF middleware, gin.TestMode, httptest).
// It returns the App, the router, and the session cookie value to pass in
// requests via the "3270Web_session" cookie.
func setupChaosTestApp(t *testing.T, mockHost *host.MockHost) (*App, *gin.Engine, string) {
	t.Helper()
	gin.SetMode(gin.TestMode)

	mgr := session.NewManager()
	sess := mgr.CreateSession(mockHost)
	sess.TargetHost = "127.0.0.1"
	sess.TargetPort = 3270

	app := &App{
		SessionManager: mgr,
		chaosEngines:   newChaosEngineStore(),
	}

	r := gin.New()
	r.POST("/chaos/start", app.ChaosStartHandler)
	r.POST("/chaos/stop", app.ChaosStopHandler)
	r.GET("/chaos/status", app.ChaosStatusHandler)
	r.POST("/chaos/export", app.ChaosExportHandler)

	return app, r, sess.ID
}

// chaosRequest is a small helper that fires an HTTP request against the test
// router, attaches the session cookie, and returns the recorder.
func chaosRequest(r *gin.Engine, method, path string, body []byte, sessID string) *httptest.ResponseRecorder {
	var req *http.Request
	if body != nil {
		req = httptest.NewRequest(method, path, bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
	} else {
		req = httptest.NewRequest(method, path, nil)
	}
	req.AddCookie(&http.Cookie{Name: "3270Web_session", Value: sessID})
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)
	return w
}

// runChaosExplorerScenarios exercises the four chaos-explorer scenarios defined
// in the problem statement for any sample-app mock screen:
//
//  1. Start chaos exploration from the toolbar (POST /chaos/start).
//  2. Verify status shows running – active indicator visible, stepsRun and
//     transitions fields present and incrementing.
//  3. Export the workflow JSON and confirm it is well-formed JSON.
//  4. Stop chaos exploration (POST /chaos/stop).
//
// The engine is started with maxSteps=0 (unlimited) and a short step delay so
// that it is still active when status and export are checked, making the test
// deterministic on any CI runner.
func runChaosExplorerScenarios(t *testing.T, screen *host.Screen, label string) {
	t.Helper()

	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("[%s] failed to create mock host: %v", label, err)
	}
	mockHost.Screen = screen
	mockHost.Connected = true

	app, r, sessID := setupChaosTestApp(t, mockHost)

	// ── 1. Start chaos exploration ──────────────────────────────────────────
	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":      0,    // unlimited – stopped manually after assertions
		"timeBudgetSec": 30,
		"stepDelaySec":  0.05, // 50 ms per step keeps the test fast
		"seed":          42,   // deterministic replay
		"maxFieldLength": 8,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/start: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var startResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &startResp); err != nil {
		t.Fatalf("[%s] start response not valid JSON: %v", label, err)
	}
	if startResp["status"] != "started" {
		t.Errorf("[%s] start: want status=started, got %v", label, startResp["status"])
	}

	// ── 2. Verify status shows running ──────────────────────────────────────
	// Poll until active=true (engine goroutine may not have set the flag yet).
	var statusResp map[string]interface{}
	deadline := time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if w.Code != http.StatusOK {
			t.Fatalf("[%s] GET /chaos/status: want 200, got %d", label, w.Code)
		}
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			t.Fatalf("[%s] status response not valid JSON: %v", label, err)
		}
		if active, _ := statusResp["active"].(bool); active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	if active, _ := statusResp["active"].(bool); !active {
		t.Errorf("[%s] status: want active=true, got %v", label, statusResp["active"])
	}
	if _, ok := statusResp["stepsRun"]; !ok {
		t.Errorf("[%s] status response missing stepsRun field", label)
	}
	if _, ok := statusResp["transitions"]; !ok {
		t.Errorf("[%s] status response missing transitions field", label)
	}

	// Poll until at least one step has been recorded (indicator incrementing).
	deadline = time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			break
		}
		if steps, _ := statusResp["stepsRun"].(float64); steps > 0 {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}
	if steps, _ := statusResp["stepsRun"].(float64); steps == 0 {
		t.Errorf("[%s] status: stepsRun never incremented above 0", label)
	}

	// ── 3. Export workflow and validate well-formed JSON ─────────────────────
	// Called while the engine is still running so the engine entry remains in
	// the store (syncChaosStatus only removes it once active=false).
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/export: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var exportedWorkflow interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &exportedWorkflow); err != nil {
		t.Fatalf("[%s] exported workflow is not valid JSON: %v", label, err)
	}
	if exportedWorkflow == nil {
		t.Errorf("[%s] exported workflow JSON must not be null", label)
	}

	// ── 4. Stop chaos exploration ─────────────────────────────────────────────
	w = chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/stop: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var stopResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &stopResp); err != nil {
		t.Fatalf("[%s] stop response not valid JSON: %v", label, err)
	}
	if st := stopResp["status"]; st != "stopping" && st != "not running" {
		t.Errorf("[%s] stop: unexpected status %q", label, st)
	}

	// Confirm engine is no longer active after stop (optional: wait for goroutine).
	deadline = time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		if eng, ok := app.chaosEngines.get(sessID); !ok || !eng.Status().Active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}
	if eng, ok := app.chaosEngines.get(sessID); ok && eng.Status().Active {
		t.Errorf("[%s] engine still active after stop", label)
	}
}

// TestChaosExplorer_SampleApp1 validates all four chaos-explorer scenarios
// against a mock screen representing SampleApp1 (name-entry form).
func TestChaosExplorer_SampleApp1(t *testing.T) {
	runChaosExplorerScenarios(t, buildSampleApp1Screen(), "SampleApp1")
}

// TestChaosExplorer_SampleApp2 validates all four chaos-explorer scenarios
// against a mock screen representing SampleApp2 (RSS newsreader).
func TestChaosExplorer_SampleApp2(t *testing.T) {
	runChaosExplorerScenarios(t, buildSampleApp2Screen(), "SampleApp2")
}

// TestChaosStart_DoubleStart ensures that starting chaos when it is already
// running returns HTTP 409 Conflict (matching the data-chaos-start selector
// being disabled in the UI when active).
func TestChaosStart_DoubleStart(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	payload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     0,
		"stepDelaySec": 0.05,
		"seed":         1,
	})

	// First start – must succeed.
	w := chaosRequest(r, http.MethodPost, "/chaos/start", payload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("first start: want 200, got %d", w.Code)
	}

	// Poll until engine is active.
	deadline := time.Now().Add(2 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		var sr map[string]interface{}
		json.Unmarshal(w.Body.Bytes(), &sr) //nolint:errcheck
		if active, _ := sr["active"].(bool); active {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}

	// Second start – must return 409.
	w = chaosRequest(r, http.MethodPost, "/chaos/start", payload, sessID)
	if w.Code != http.StatusConflict {
		t.Errorf("double start: want 409, got %d – body: %s", w.Code, w.Body.String())
	}

	// Clean up.
	chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID) //nolint:errcheck
}

// TestChaosStop_WhenNotRunning ensures that stopping when no engine is active
// returns HTTP 200 with status "not running" (matching the data-chaos-stop
// hidden-by-default behaviour in the UI).
func TestChaosStop_WhenNotRunning(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("stop when not running: want 200, got %d", w.Code)
	}
	var resp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &resp); err != nil {
		t.Fatalf("stop response not valid JSON: %v", err)
	}
	if resp["status"] != "not running" {
		t.Errorf("want status=not running, got %q", resp["status"])
	}
}

// TestChaosExport_WithoutEngine ensures that calling export before starting
// chaos returns HTTP 404 (matching the data-chaos-export hidden-by-default
// behaviour in the UI – the button is only shown after a run).
func TestChaosExport_WithoutEngine(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusNotFound {
		t.Errorf("export without engine: want 404, got %d – body: %s", w.Code, w.Body.String())
	}
}

// TestChaosStatus_NoSession verifies that requests without a valid session
// cookie return HTTP 401, exercising the data-chaos-indicator hidden path.
func TestChaosStatus_NoSession(t *testing.T) {
	gin.SetMode(gin.TestMode)

	mgr := session.NewManager()
	app := &App{
		SessionManager: mgr,
		chaosEngines:   newChaosEngineStore(),
	}
	r := gin.New()
	r.GET("/chaos/status", app.ChaosStatusHandler)

	req := httptest.NewRequest(http.MethodGet, "/chaos/status", nil)
	// No session cookie attached.
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)

	if w.Code != http.StatusUnauthorized {
		t.Errorf("no session: want 401, got %d", w.Code)
	}
}
