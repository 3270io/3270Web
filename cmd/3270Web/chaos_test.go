package main

import (
	"bytes"
	"encoding/json"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/jnnngs/3270Web/internal/host"
	"github.com/jnnngs/3270Web/internal/session"
)

// buildSampleApp1Screen returns a mock 3270 screen that resembles SampleApp1
// (a name-entry and validation form). It has protected label fields and three
// unprotected input fields (first name, last name, password), mirroring the
// real app1 layout used by the go3270 sample application.
func buildSampleApp1Screen() *host.Screen {
	s := &host.Screen{
		Width:       80,
		Height:      24,
		IsFormatted: true,
		Buffer:      make([][]rune, 24),
	}
	for i := range s.Buffer {
		s.Buffer[i] = make([]rune, 80)
	}
	// Protected label: "First Name:" at row 3, cols 0-10
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 3, 10, 3, 0, 0))
	// Unprotected input for first name at row 3, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 3, 30, 3, 0, 0))
	// Protected label: "Last Name:" at row 5, cols 0-9
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 5, 9, 5, 0, 0))
	// Unprotected input for last name at row 5, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 5, 30, 5, 0, 0))
	// Protected label: "Password:" at row 7, cols 0-8
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 7, 8, 7, 0, 0))
	// Unprotected input for password at row 7, cols 12-30
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 12, 7, 30, 7, 0, 0))
	return s
}

// buildSampleApp2Screen returns a mock 3270 screen that resembles SampleApp2
// (an RSS newsreader). Most of the screen is protected content (headlines) with
// a single unprotected selection/navigation field, reflecting the real app2
// layout generated by the go3270 newsreader.
func buildSampleApp2Screen() *host.Screen {
	s := &host.Screen{
		Width:       80,
		Height:      24,
		IsFormatted: true,
		Buffer:      make([][]rune, 24),
	}
	for i := range s.Buffer {
		s.Buffer[i] = make([]rune, 80)
	}
	// Protected header row (title bar) at row 0
	s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, 0, 79, 0, 0, 0))
	// Protected news headline rows (rows 2, 4, 6, 8, 10, 12, 14, 16, 18)
	for row := 2; row <= 18; row += 2 {
		s.Fields = append(s.Fields, host.NewField(s, host.AttrProtected, 0, row, 79, row, 0, 0))
	}
	// Unprotected selection/navigation input at row 20, cols 0-4
	s.Fields = append(s.Fields, host.NewField(s, 0x00, 0, 20, 4, 20, 0, 0))
	return s
}

// setupChaosTestApp creates a minimal App with a pre-seeded session and a Gin
// router that exposes only the chaos endpoints. It mirrors the pattern used
// throughout main_test.go (no CSRF middleware, gin.TestMode, httptest).
// It returns the App, the router, and the session cookie value to pass in
// requests via the "3270Web_session" cookie.
func setupChaosTestApp(t *testing.T, mockHost *host.MockHost) (*App, *gin.Engine, string) {
	t.Helper()
	gin.SetMode(gin.TestMode)

	mgr := session.NewManager()
	sess := mgr.CreateSession(mockHost)
	sess.TargetHost = "127.0.0.1"
	sess.TargetPort = 3270

	app := &App{
		SessionManager: mgr,
		chaosEngines:   newChaosEngineStore(),
		chaosHintsPath: filepath.Join(t.TempDir(), "chaos-hints.json"),
	}

	r := gin.New()
	r.POST("/chaos/start", app.ChaosStartHandler)
	r.POST("/chaos/stop", app.ChaosStopHandler)
	r.POST("/chaos/remove", app.ChaosRemoveHandler)
	r.GET("/chaos/status", app.ChaosStatusHandler)
	r.POST("/chaos/export", app.ChaosExportHandler)
	r.POST("/chaos/load-recording", app.ChaosLoadRecordingHandler)
	r.GET("/chaos/hints", app.ChaosHintsGetHandler)
	r.POST("/chaos/hints", app.ChaosHintsSaveHandler)
	r.POST("/chaos/hints/extract-recording", app.ChaosHintsExtractHandler)

	return app, r, sess.ID
}

// chaosRequest is a small helper that fires an HTTP request against the test
// router, attaches the session cookie, and returns the recorder.
func chaosRequest(r *gin.Engine, method, path string, body []byte, sessID string) *httptest.ResponseRecorder {
	var req *http.Request
	if body != nil {
		req = httptest.NewRequest(method, path, bytes.NewReader(body))
		req.Header.Set("Content-Type", "application/json")
	} else {
		req = httptest.NewRequest(method, path, nil)
	}
	req.AddCookie(&http.Cookie{Name: "3270Web_session", Value: sessID})
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)
	return w
}

func chaosMultipartRequest(r *gin.Engine, path, fieldName, fileName string, payload []byte, sessID string) *httptest.ResponseRecorder {
	var reqBody bytes.Buffer
	writer := multipart.NewWriter(&reqBody)
	part, err := writer.CreateFormFile(fieldName, fileName)
	if err == nil {
		_, _ = part.Write(payload)
	}
	_ = writer.Close()

	req := httptest.NewRequest(http.MethodPost, path, &reqBody)
	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.AddCookie(&http.Cookie{Name: "3270Web_session", Value: sessID})
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)
	return w
}

// runChaosExplorerScenarios exercises the four chaos-explorer scenarios defined
// in the problem statement for any sample-app mock screen:
//
//  1. Start chaos exploration from the toolbar (POST /chaos/start).
//  2. Verify status shows running – active indicator visible, stepsRun and
//     transitions fields present and incrementing.
//  3. Export the workflow JSON and confirm it is well-formed JSON.
//  4. Stop chaos exploration (POST /chaos/stop).
//
// The engine is started with maxSteps=0 (unlimited) and a short step delay so
// that it is still active when status and export are checked, making the test
// deterministic on any CI runner.
func runChaosExplorerScenarios(t *testing.T, screen *host.Screen, label string) {
	t.Helper()

	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("[%s] failed to create mock host: %v", label, err)
	}
	mockHost.Screen = screen
	mockHost.Connected = true

	app, r, sessID := setupChaosTestApp(t, mockHost)

	// ── 1. Start chaos exploration ──────────────────────────────────────────
	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":       0, // unlimited – stopped manually after assertions
		"timeBudgetSec":  30,
		"stepDelaySec":   0.05, // 50 ms per step keeps the test fast
		"seed":           42,   // deterministic replay
		"maxFieldLength": 8,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/start: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var startResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &startResp); err != nil {
		t.Fatalf("[%s] start response not valid JSON: %v", label, err)
	}
	if startResp["status"] != "started" {
		t.Errorf("[%s] start: want status=started, got %v", label, startResp["status"])
	}

	// ── 2. Verify status shows running ──────────────────────────────────────
	// Poll until active=true (engine goroutine may not have set the flag yet).
	var statusResp map[string]interface{}
	deadline := time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if w.Code != http.StatusOK {
			t.Fatalf("[%s] GET /chaos/status: want 200, got %d", label, w.Code)
		}
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			t.Fatalf("[%s] status response not valid JSON: %v", label, err)
		}
		if active, _ := statusResp["active"].(bool); active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	if active, _ := statusResp["active"].(bool); !active {
		t.Errorf("[%s] status: want active=true, got %v", label, statusResp["active"])
	}
	if _, ok := statusResp["stepsRun"]; !ok {
		t.Errorf("[%s] status response missing stepsRun field", label)
	}
	if _, ok := statusResp["transitions"]; !ok {
		t.Errorf("[%s] status response missing transitions field", label)
	}

	// Poll until at least one step has been recorded (indicator incrementing).
	deadline = time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			break
		}
		if steps, _ := statusResp["stepsRun"].(float64); steps > 0 {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}
	if steps, _ := statusResp["stepsRun"].(float64); steps == 0 {
		t.Errorf("[%s] status: stepsRun never incremented above 0", label)
	}

	// ── 3. Export workflow and validate well-formed JSON ─────────────────────
	// Called while the engine is still running so the engine entry remains in
	// the store (syncChaosStatus only removes it once active=false).
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/export: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var exportedWorkflow WorkflowConfig
	if err := json.Unmarshal(w.Body.Bytes(), &exportedWorkflow); err != nil {
		t.Fatalf("[%s] exported workflow is not valid JSON: %v", label, err)
	}
	if len(exportedWorkflow.Steps) == 0 {
		t.Errorf("[%s] exported workflow must include steps", label)
	}
	if exportedWorkflow.EveryStepDelay == nil {
		t.Errorf("[%s] exported workflow missing EveryStepDelay header", label)
	} else if exportedWorkflow.EveryStepDelay.Min != 0.05 || exportedWorkflow.EveryStepDelay.Max != 0.05 {
		t.Errorf("[%s] EveryStepDelay = %+v, want Min=Max=0.05", label, exportedWorkflow.EveryStepDelay)
	}

	// ── 4. Stop chaos exploration ─────────────────────────────────────────────
	w = chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("[%s] POST /chaos/stop: want 200, got %d – body: %s", label, w.Code, w.Body.String())
	}
	var stopResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &stopResp); err != nil {
		t.Fatalf("[%s] stop response not valid JSON: %v", label, err)
	}
	if st := stopResp["status"]; st != "stopping" && st != "not running" {
		t.Errorf("[%s] stop: unexpected status %q", label, st)
	}

	// Confirm engine is no longer active after stop (optional: wait for goroutine).
	deadline = time.Now().Add(3 * time.Second)
	for time.Now().Before(deadline) {
		if eng, ok := app.chaosEngines.get(sessID); !ok || !eng.Status().Active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}
	if eng, ok := app.chaosEngines.get(sessID); ok && eng.Status().Active {
		t.Errorf("[%s] engine still active after stop", label)
	}
}

// TestChaosExplorer_SampleApp1 validates all four chaos-explorer scenarios
// against a mock screen representing SampleApp1 (name-entry form).
func TestChaosExplorer_SampleApp1(t *testing.T) {
	runChaosExplorerScenarios(t, buildSampleApp1Screen(), "SampleApp1")
}

// TestChaosExplorer_SampleApp2 validates all four chaos-explorer scenarios
// against a mock screen representing SampleApp2 (RSS newsreader).
func TestChaosExplorer_SampleApp2(t *testing.T) {
	runChaosExplorerScenarios(t, buildSampleApp2Screen(), "SampleApp2")
}

// TestChaosStart_DoubleStart ensures that starting chaos when it is already
// running returns HTTP 409 Conflict (matching the data-chaos-start selector
// being disabled in the UI when active).
func TestChaosStart_DoubleStart(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	payload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     0,
		"stepDelaySec": 0.05,
		"seed":         1,
	})

	// First start – must succeed.
	w := chaosRequest(r, http.MethodPost, "/chaos/start", payload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("first start: want 200, got %d", w.Code)
	}

	// Poll until engine is active.
	deadline := time.Now().Add(2 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		var sr map[string]interface{}
		json.Unmarshal(w.Body.Bytes(), &sr) //nolint:errcheck
		if active, _ := sr["active"].(bool); active {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}

	// Second start – must return 409.
	w = chaosRequest(r, http.MethodPost, "/chaos/start", payload, sessID)
	if w.Code != http.StatusConflict {
		t.Errorf("double start: want 409, got %d – body: %s", w.Code, w.Body.String())
	}

	// Clean up.
	chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID) //nolint:errcheck
}

// TestChaosStop_WhenNotRunning ensures that stopping when no engine is active
// returns HTTP 200 with status "not running" (matching the data-chaos-stop
// hidden-by-default behaviour in the UI).
func TestChaosStop_WhenNotRunning(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodPost, "/chaos/stop", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("stop when not running: want 200, got %d", w.Code)
	}
	var resp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &resp); err != nil {
		t.Fatalf("stop response not valid JSON: %v", err)
	}
	if resp["status"] != "not running" {
		t.Errorf("want status=not running, got %q", resp["status"])
	}
}

// TestChaosExport_WithoutEngine ensures that calling export before starting
// chaos returns HTTP 404 (matching the data-chaos-export hidden-by-default
// behaviour in the UI – the button is only shown after a run).
func TestChaosExport_WithoutEngine(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusNotFound {
		t.Errorf("export without engine: want 404, got %d – body: %s", w.Code, w.Body.String())
	}
}

// TestChaosExport_AfterCompletion verifies that export remains available after
// a chaos run has completed and its engine has been removed from the store.
func TestChaosExport_AfterCompletion(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     2,
		"stepDelaySec": 0,
		"seed":         123,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d – body: %s", w.Code, w.Body.String())
	}

	// Wait for the engine to complete and be removed by syncChaosStatus.
	deadline := time.Now().Add(6 * time.Second)
	for time.Now().Before(deadline) {
		if _, ok := app.chaosEngines.get(sessID); !ok {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}
	if _, ok := app.chaosEngines.get(sessID); ok {
		t.Fatal("expected chaos engine to be removed after completion")
	}

	// Status should still include saved run details.
	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("status: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var statusResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
		t.Fatalf("status response not valid JSON: %v", err)
	}
	if got, _ := statusResp["stepsRun"].(float64); got < 1 {
		t.Fatalf("status stepsRun = %v, want > 0", statusResp["stepsRun"])
	}
	runID, _ := statusResp["loadedRunID"].(string)
	if runID == "" {
		t.Fatalf("status loadedRunID = %q, want non-empty", runID)
	}

	// Export should succeed from saved run data, even without a live engine.
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("export after completion: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var exported WorkflowConfig
	if err := json.Unmarshal(w.Body.Bytes(), &exported); err != nil {
		t.Fatalf("exported workflow is not valid JSON: %v", err)
	}
	if len(exported.Steps) == 0 {
		t.Fatal("exported workflow contains no steps")
	}
}

// TestChaosExport_AfterCompletion_FallbackFromDisk verifies export still works
// if in-memory loaded run state is missing but the completed run was saved.
func TestChaosExport_AfterCompletion_FallbackFromDisk(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     2,
		"stepDelaySec": 0,
		"seed":         456,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d – body: %s", w.Code, w.Body.String())
	}

	// Wait until status reports completion and includes loadedRunID.
	var statusResp map[string]interface{}
	var runID string
	deadline := time.Now().Add(6 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if w.Code != http.StatusOK {
			t.Fatalf("status: want 200, got %d – body: %s", w.Code, w.Body.String())
		}
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			t.Fatalf("status response not valid JSON: %v", err)
		}
		active, _ := statusResp["active"].(bool)
		runID, _ = statusResp["loadedRunID"].(string)
		if !active && runID != "" {
			break
		}
		time.Sleep(25 * time.Millisecond)
	}
	if runID == "" {
		t.Fatal("expected completed runID in status")
	}

	// Simulate lost in-memory run cache for this session.
	app.chaosEngines.mu.Lock()
	delete(app.chaosEngines.loadedRuns, sessID)
	app.chaosEngines.mu.Unlock()

	// Export must recover from disk via session loadedRunID.
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("export fallback: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var exported WorkflowConfig
	if err := json.Unmarshal(w.Body.Bytes(), &exported); err != nil {
		t.Fatalf("exported workflow is not valid JSON: %v", err)
	}
	if len(exported.Steps) == 0 {
		t.Fatal("exported workflow contains no steps")
	}
}

// TestChaosStatus_NoSession verifies that requests without a valid session
// cookie return HTTP 401, exercising the data-chaos-indicator hidden path.
func TestChaosStatus_NoSession(t *testing.T) {
	gin.SetMode(gin.TestMode)

	mgr := session.NewManager()
	app := &App{
		SessionManager: mgr,
		chaosEngines:   newChaosEngineStore(),
	}
	r := gin.New()
	r.GET("/chaos/status", app.ChaosStatusHandler)

	req := httptest.NewRequest(http.MethodGet, "/chaos/status", nil)
	// No session cookie attached.
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)

	if w.Code != http.StatusUnauthorized {
		t.Errorf("no session: want 401, got %d", w.Code)
	}
}

// setupFullChaosTestApp creates a test App with all chaos routes registered,
// including the persistence routes (/chaos/runs, /chaos/load, /chaos/resume).
// It uses t.TempDir() for the chaosRunsDir so that each test gets an isolated
// directory that is cleaned up automatically.
func setupFullChaosTestApp(t *testing.T, mockHost *host.MockHost) (*App, *gin.Engine, string) {
	t.Helper()
	gin.SetMode(gin.TestMode)

	mgr := session.NewManager()
	sess := mgr.CreateSession(mockHost)
	sess.TargetHost = "127.0.0.1"
	sess.TargetPort = 3270

	app := &App{
		SessionManager: mgr,
		chaosEngines:   newChaosEngineStore(),
		chaosRunsDir:   t.TempDir(),
		chaosHintsPath: filepath.Join(t.TempDir(), "chaos-hints.json"),
	}

	r := gin.New()
	r.POST("/chaos/start", app.ChaosStartHandler)
	r.POST("/chaos/stop", app.ChaosStopHandler)
	r.POST("/chaos/remove", app.ChaosRemoveHandler)
	r.GET("/chaos/status", app.ChaosStatusHandler)
	r.POST("/chaos/export", app.ChaosExportHandler)
	r.GET("/chaos/runs", app.ChaosListRunsHandler)
	r.POST("/chaos/load", app.ChaosLoadHandler)
	r.POST("/chaos/load-recording", app.ChaosLoadRecordingHandler)
	r.POST("/chaos/resume", app.ChaosResumeHandler)
	r.GET("/chaos/hints", app.ChaosHintsGetHandler)
	r.POST("/chaos/hints", app.ChaosHintsSaveHandler)
	r.POST("/chaos/hints/extract-recording", app.ChaosHintsExtractHandler)

	return app, r, sess.ID
}

// TestChaosStatus_MetadataFields verifies that the status response includes
// the new metadata fields (uniqueScreens, uniqueInputs) introduced for
// discovery tracking.
func TestChaosStatus_MetadataFields(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     3,
		"stepDelaySec": 0,
		"seed":         10,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d", w.Code)
	}

	// Wait for engine to finish (MaxSteps=3, no delay).
	deadline := time.Now().Add(5 * time.Second)
	var statusResp map[string]interface{}
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		json.Unmarshal(w.Body.Bytes(), &statusResp) //nolint:errcheck
		if active, _ := statusResp["active"].(bool); !active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("status: want 200, got %d", w.Code)
	}
	if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
		t.Fatalf("status not valid JSON: %v", err)
	}
	if _, ok := statusResp["uniqueScreens"]; !ok {
		t.Error("status response missing uniqueScreens field")
	}
	if _, ok := statusResp["uniqueInputs"]; !ok {
		t.Error("status response missing uniqueInputs field")
	}
	if _, ok := statusResp["mindMap"]; !ok {
		t.Error("status response missing mindMap field")
	}
}

// TestChaosListRuns_Empty verifies that listing runs when the directory is
// empty returns an empty JSON array.
func TestChaosListRuns_Empty(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodGet, "/chaos/runs", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("list runs: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var runs []interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &runs); err != nil {
		t.Fatalf("list runs response not valid JSON: %v", err)
	}
	if len(runs) != 0 {
		t.Errorf("want empty list, got %d entries", len(runs))
	}
}

func TestChaosHints_SaveAndLoad(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	savePayload, _ := json.Marshal(map[string]interface{}{
		"hints": []map[string]interface{}{
			{
				"transaction": " CEMT ",
				"knownData":   []string{" USER01 ", "", "PASS01", "PASS01"},
			},
			{
				"transaction": "",
				"knownData":   []string{"  ", "ACCT123"},
			},
		},
	})

	w := chaosRequest(r, http.MethodPost, "/chaos/hints", savePayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("save hints: want 200, got %d body=%s", w.Code, w.Body.String())
	}

	var saveResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &saveResp); err != nil {
		t.Fatalf("save hints response is not valid JSON: %v", err)
	}
	if saveResp["status"] != "saved" {
		t.Fatalf("save hints status = %v, want saved", saveResp["status"])
	}

	w = chaosRequest(r, http.MethodGet, "/chaos/hints", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("load hints: want 200, got %d body=%s", w.Code, w.Body.String())
	}

	var loadResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &loadResp); err != nil {
		t.Fatalf("load hints response is not valid JSON: %v", err)
	}
	hints, ok := loadResp["hints"].([]interface{})
	if !ok {
		t.Fatalf("hints payload has wrong type: %T", loadResp["hints"])
	}
	if len(hints) != 2 {
		t.Fatalf("hints length = %d, want 2", len(hints))
	}
	first, _ := hints[0].(map[string]interface{})
	if tx, _ := first["transaction"].(string); tx != "CEMT" {
		t.Fatalf("first hint transaction = %q, want CEMT", tx)
	}
	firstKnown, _ := first["knownData"].([]interface{})
	if len(firstKnown) != 2 {
		t.Fatalf("first hint knownData length = %d, want 2", len(firstKnown))
	}
}

func TestChaosHints_ExtractFromRecordingUpload(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	workflowPayload, _ := json.Marshal(map[string]interface{}{
		"Host": "127.0.0.1",
		"Port": 3270,
		"Steps": []map[string]interface{}{
			{"Type": "FillString", "Text": "cemt"},
			{"Type": "FillString", "Text": "USER01"},
			{"Type": "Enter"},
			{"Type": "FillString", "Text": "CESN"},
			{"Type": "FillString", "Text": "PASS01"},
		},
	})

	w := chaosMultipartRequest(r, "/chaos/hints/extract-recording", "workflow", "workflow.json", workflowPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("extract hints: want 200, got %d body=%s", w.Code, w.Body.String())
	}
	var resp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &resp); err != nil {
		t.Fatalf("extract response not valid JSON: %v", err)
	}
	if got, _ := resp["source"].(string); got != "upload" {
		t.Fatalf("source = %q, want upload", got)
	}
	hints, ok := resp["hints"].([]interface{})
	if !ok || len(hints) == 0 {
		t.Fatalf("hints = %#v, want non-empty array", resp["hints"])
	}
	first, _ := hints[0].(map[string]interface{})
	if tx, _ := first["transaction"].(string); tx == "" {
		t.Fatalf("first transaction is empty")
	}
}

func TestChaosHints_ExtractFromLoadedRecording(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)
	s, ok := app.SessionManager.GetSession(sessID)
	if !ok {
		t.Fatalf("session %q not found", sessID)
	}

	workflowPayload, _ := json.Marshal(map[string]interface{}{
		"Host": "127.0.0.1",
		"Port": 3270,
		"Steps": []map[string]interface{}{
			{"Type": "FillString", "Text": "CEMT"},
			{"Type": "FillString", "Text": "USER01"},
			{"Type": "Enter"},
		},
	})
	withSessionLock(s, func() {
		s.LoadedWorkflow = &session.LoadedWorkflow{
			Name:     "loaded-workflow.json",
			Payload:  workflowPayload,
			Preview:  string(workflowPayload),
			LoadedAt: time.Now(),
		}
	})

	w := chaosRequest(r, http.MethodPost, "/chaos/hints/extract-recording", []byte("{}"), sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("extract hints from loaded: want 200, got %d body=%s", w.Code, w.Body.String())
	}
	var resp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &resp); err != nil {
		t.Fatalf("extract response not valid JSON: %v", err)
	}
	if got, _ := resp["source"].(string); got != "loaded" {
		t.Fatalf("source = %q, want loaded", got)
	}
	hints, ok := resp["hints"].([]interface{})
	if !ok || len(hints) == 0 {
		t.Fatalf("hints = %#v, want non-empty array", resp["hints"])
	}
}

func TestChaosLoadRecordingAndExport(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)
	s, ok := app.SessionManager.GetSession(sessID)
	if !ok {
		t.Fatalf("session %q not found", sessID)
	}

	workflowPayload, _ := json.Marshal(map[string]interface{}{
		"Host": "127.0.0.1",
		"Port": 3270,
		"EveryStepDelay": map[string]interface{}{
			"Min": 0.2,
			"Max": 0.4,
		},
		"RampUpBatchSize": 23,
		"RampUpDelay":     2.2,
		"EndOfTaskDelay": map[string]interface{}{
			"Min": 11,
			"Max": 17,
		},
		"Steps": []map[string]interface{}{
			{
				"Type": "FillString",
				"Coordinates": map[string]interface{}{
					"Row":    1,
					"Column": 1,
				},
				"Text": "CEMT",
			},
			{
				"Type": "Enter",
			},
		},
	})
	withSessionLock(s, func() {
		s.LoadedWorkflow = &session.LoadedWorkflow{
			Name:     "workflow.json",
			Payload:  workflowPayload,
			Preview:  string(workflowPayload),
			LoadedAt: time.Now(),
		}
	})

	w := chaosRequest(r, http.MethodPost, "/chaos/load-recording", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("load recording: want 200, got %d body=%s", w.Code, w.Body.String())
	}

	var loadResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &loadResp); err != nil {
		t.Fatalf("load response not valid JSON: %v", err)
	}
	if got, _ := loadResp["status"].(string); got != "loaded" {
		t.Fatalf("load status = %q, want loaded", got)
	}
	if got, _ := loadResp["source"].(string); got != "recording" {
		t.Fatalf("load source = %q, want recording", got)
	}
	if got, _ := loadResp["stepsSeeded"].(float64); int(got) != 2 {
		t.Fatalf("stepsSeeded = %v, want 2", loadResp["stepsSeeded"])
	}
	if got, _ := loadResp["runID"].(string); got == "" {
		t.Fatalf("runID is empty")
	}

	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("status after load recording: want 200, got %d body=%s", w.Code, w.Body.String())
	}
	var statusResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
		t.Fatalf("status response not valid JSON: %v", err)
	}
	if _, ok := statusResp["mindMap"]; !ok {
		t.Fatalf("status after load recording missing mindMap field")
	}

	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("export: want 200, got %d body=%s", w.Code, w.Body.String())
	}
	var exported WorkflowConfig
	if err := json.Unmarshal(w.Body.Bytes(), &exported); err != nil {
		t.Fatalf("export response not valid JSON: %v", err)
	}
	if len(exported.Steps) != 2 {
		t.Fatalf("export steps = %d, want 2", len(exported.Steps))
	}
	if exported.EveryStepDelay == nil || exported.EveryStepDelay.Min != 0.2 || exported.EveryStepDelay.Max != 0.4 {
		t.Fatalf("export EveryStepDelay = %+v, want Min=0.2 Max=0.4", exported.EveryStepDelay)
	}
	if exported.RampUpBatchSize != 23 {
		t.Fatalf("export RampUpBatchSize = %d, want 23", exported.RampUpBatchSize)
	}
	if exported.RampUpDelay != 2.2 {
		t.Fatalf("export RampUpDelay = %v, want 2.2", exported.RampUpDelay)
	}
	if exported.EndOfTaskDelay == nil || exported.EndOfTaskDelay.Min != 11 || exported.EndOfTaskDelay.Max != 17 {
		t.Fatalf("export EndOfTaskDelay = %+v, want Min=11 Max=17", exported.EndOfTaskDelay)
	}
	if exported.Steps[0].Type != "FillString" || exported.Steps[0].Text != "CEMT" {
		t.Fatalf("first exported step = %#v, want FillString/CEMT", exported.Steps[0])
	}
}

func TestSafeChaosOutputFilePath_AvoidsLoadedRecordingCollision(t *testing.T) {
	got := safeChaosOutputFilePath(filepath.Join("tmp", "workflow.json"), "workflow.json")
	want := filepath.Join("tmp", "workflow-chaos.json")
	if got != want {
		t.Fatalf("safeChaosOutputFilePath collision = %q, want %q", got, want)
	}

	got = safeChaosOutputFilePath(filepath.Join("tmp", "workflow-chaos.json"), "workflow-chaos.json")
	want = filepath.Join("tmp", "workflow-chaos.json")
	if got != want {
		t.Fatalf("safeChaosOutputFilePath idempotent = %q, want %q", got, want)
	}

	got = safeChaosOutputFilePath(filepath.Join("tmp", "chaos-output.json"), "workflow.json")
	want = filepath.Join("tmp", "chaos-output.json")
	if got != want {
		t.Fatalf("safeChaosOutputFilePath no-collision = %q, want %q", got, want)
	}
}

func TestChaosStart_OutputFileDoesNotOverwriteLoadedRecording(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)
	s, ok := app.SessionManager.GetSession(sessID)
	if !ok {
		t.Fatalf("session %q not found", sessID)
	}

	recordingPayload, _ := json.Marshal(map[string]interface{}{
		"Host": "127.0.0.1",
		"Port": 3270,
		"Steps": []map[string]interface{}{
			{"Type": "Enter"},
		},
	})
	withSessionLock(s, func() {
		s.LoadedWorkflow = &session.LoadedWorkflow{
			Name:     "recording.json",
			Payload:  recordingPayload,
			Preview:  string(recordingPayload),
			LoadedAt: time.Now(),
		}
	})

	outputDir := t.TempDir()
	recordingPath := filepath.Join(outputDir, "recording.json")
	sentinel := []byte("{\"recording\":true}\n")
	if err := os.WriteFile(recordingPath, sentinel, 0600); err != nil {
		t.Fatalf("write sentinel recording file: %v", err)
	}

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     1,
		"stepDelaySec": 0,
		"seed":         77,
		"outputFile":   recordingPath,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d body=%s", w.Code, w.Body.String())
	}

	deadline := time.Now().Add(5 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		var status map[string]interface{}
		_ = json.Unmarshal(w.Body.Bytes(), &status)
		if active, _ := status["active"].(bool); !active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	gotRecording, err := os.ReadFile(recordingPath)
	if err != nil {
		t.Fatalf("read recording file: %v", err)
	}
	if !bytes.Equal(gotRecording, sentinel) {
		t.Fatalf("recording file was overwritten: got %q, want %q", string(gotRecording), string(sentinel))
	}

	chaosPath := filepath.Join(outputDir, "recording-chaos.json")
	chaosData, err := os.ReadFile(chaosPath)
	if err != nil {
		t.Fatalf("read chaos output file: %v", err)
	}
	if len(chaosData) == 0 {
		t.Fatalf("chaos output file is empty")
	}
	var chaosWorkflow WorkflowConfig
	if err := json.Unmarshal(chaosData, &chaosWorkflow); err != nil {
		t.Fatalf("chaos output workflow is not valid JSON: %v", err)
	}
	if chaosWorkflow.EveryStepDelay == nil {
		t.Fatalf("chaos output workflow missing EveryStepDelay header")
	}
}

// TestChaosLoadAndResume verifies the load→resume workflow: a run is saved to
// disk, loaded via POST /chaos/load, and then resumed via POST /chaos/resume.
func TestChaosLoadAndResume(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)
	sess, ok := app.SessionManager.GetSession(sessID)
	if !ok {
		t.Fatalf("session %q not found", sessID)
	}

	// ── 1. Run a short chaos exploration so a run is auto-saved. ─────────────
	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     3,
		"stepDelaySec": 0,
		"seed":         20,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d", w.Code)
	}

	// Wait for the engine to finish and the auto-save to happen.
	deadline := time.Now().Add(5 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		var sr map[string]interface{}
		json.Unmarshal(w.Body.Bytes(), &sr) //nolint:errcheck
		if active, _ := sr["active"].(bool); !active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	// Wait a little extra for the syncChaosStatus goroutine to detect
	// engine completion and auto-save (it polls every 500 ms).
	var metas []map[string]interface{}
	saveDeadline := time.Now().Add(3 * time.Second)
	for time.Now().Before(saveDeadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/runs", nil, sessID)
		if w.Code == http.StatusOK {
			json.Unmarshal(w.Body.Bytes(), &metas) //nolint:errcheck
			if len(metas) > 0 {
				break
			}
		}
		time.Sleep(50 * time.Millisecond)
	}

	// ── 2. List saved runs – expect at least one. ──────────────────────────
	if w.Code != http.StatusOK {
		t.Fatalf("list runs: want 200, got %d", w.Code)
	}
	if len(metas) == 0 {
		t.Fatal("expected at least one saved run after exploration")
	}
	runID, _ := metas[0]["id"].(string)
	if runID == "" {
		t.Fatal("saved run missing id field")
	}

	// ── 3. Load the saved run. ─────────────────────────────────────────────
	loadPayload, _ := json.Marshal(map[string]interface{}{"runID": runID})
	withSessionLock(sess, func() {
		sess.Chaos = &session.ChaosState{
			Active:      false,
			StepsRun:    99,
			Transitions: 50,
			LoadedRunID: "stale-run",
		}
	})
	w = chaosRequest(r, http.MethodPost, "/chaos/load", loadPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("load: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var loadResp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &loadResp); err != nil {
		t.Fatalf("load response not valid JSON: %v", err)
	}
	if loadResp["runID"] != runID {
		t.Errorf("load response runID = %v, want %q", loadResp["runID"], runID)
	}
	withSessionLock(sess, func() {
		if sess.Chaos != nil {
			t.Fatalf("session chaos state should be cleared on load")
		}
	})

	// Status should now report loadedRunID even without a running engine.
	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	var statusResp map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &statusResp) //nolint:errcheck
	if statusResp["loadedRunID"] != runID {
		t.Errorf("status loadedRunID = %v, want %q", statusResp["loadedRunID"], runID)
	}

	// ── 4. Resume exploration from the loaded run. ─────────────────────────
	resumePayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     2,
		"stepDelaySec": 0,
		"seed":         99,
	})
	w = chaosRequest(r, http.MethodPost, "/chaos/resume", resumePayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("resume: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	var resumeResp map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &resumeResp) //nolint:errcheck
	if resumeResp["status"] != "resumed" {
		t.Errorf("resume response status = %v, want \"resumed\"", resumeResp["status"])
	}
	if resumeResp["loadedRunID"] != runID {
		t.Errorf("resume response loadedRunID = %v, want %q", resumeResp["loadedRunID"], runID)
	}

	// Wait for resumed engine to finish.
	deadline = time.Now().Add(5 * time.Second)
	for time.Now().Before(deadline) {
		if eng, ok := app.chaosEngines.get(sessID); !ok || !eng.Status().Active {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	// Status should show loadedRunID from the resumed engine.
	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	json.Unmarshal(w.Body.Bytes(), &statusResp) //nolint:errcheck
	// After the resumed engine finishes, loadedRunID may appear in the loaded
	// run store (set via setLoadedRun) or in the status; either is acceptable.
}

// TestChaosLoad_NotFound verifies that loading a non-existent run ID returns 404.
func TestChaosLoad_NotFound(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	loadPayload, _ := json.Marshal(map[string]interface{}{"runID": "nonexistent-run"})
	w := chaosRequest(r, http.MethodPost, "/chaos/load", loadPayload, sessID)
	if w.Code != http.StatusNotFound {
		t.Errorf("load nonexistent: want 404, got %d – body: %s", w.Code, w.Body.String())
	}
}

// TestChaosResume_WithoutLoad verifies that calling resume before loading a
// run returns HTTP 400.
func TestChaosResume_WithoutLoad(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	w := chaosRequest(r, http.MethodPost, "/chaos/resume", nil, sessID)
	if w.Code != http.StatusBadRequest {
		t.Errorf("resume without load: want 400, got %d – body: %s", w.Code, w.Body.String())
	}
}

func TestChaosResume_InvalidLoadedRun(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Connected = true

	app, r, sessID := setupFullChaosTestApp(t, mockHost)
	app.chaosEngines.setLoadedRun(sessID, nil)

	w := chaosRequest(r, http.MethodPost, "/chaos/resume", nil, sessID)
	if w.Code != http.StatusBadRequest {
		t.Errorf("resume with invalid loaded run: want 400, got %d – body: %s", w.Code, w.Body.String())
	}
	var resp map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &resp); err != nil {
		t.Fatalf("resume response not valid JSON: %v", err)
	}
	if got, _ := resp["error"].(string); got != "loaded run is invalid; load a run again" {
		t.Errorf("resume error = %q, want %q", got, "loaded run is invalid; load a run again")
	}
}

func TestChaosRemove_AfterCompletion(t *testing.T) {
	mockHost, err := host.NewMockHost("")
	if err != nil {
		t.Fatalf("failed to create mock host: %v", err)
	}
	mockHost.Screen = buildSampleApp1Screen()
	mockHost.Connected = true

	_, r, sessID := setupFullChaosTestApp(t, mockHost)

	startPayload, _ := json.Marshal(map[string]interface{}{
		"maxSteps":     2,
		"stepDelaySec": 0,
		"seed":         777,
	})
	w := chaosRequest(r, http.MethodPost, "/chaos/start", startPayload, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("start: want 200, got %d – body: %s", w.Code, w.Body.String())
	}

	// Wait for completed status and loaded run data.
	var statusResp map[string]interface{}
	deadline := time.Now().Add(6 * time.Second)
	for time.Now().Before(deadline) {
		w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
		if w.Code != http.StatusOK {
			t.Fatalf("status: want 200, got %d – body: %s", w.Code, w.Body.String())
		}
		if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
			t.Fatalf("status response not valid JSON: %v", err)
		}
		active, _ := statusResp["active"].(bool)
		stepsRun, _ := statusResp["stepsRun"].(float64)
		runID, _ := statusResp["loadedRunID"].(string)
		if !active && stepsRun > 0 && runID != "" {
			break
		}
		time.Sleep(20 * time.Millisecond)
	}

	w = chaosRequest(r, http.MethodPost, "/chaos/remove", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("remove: want 200, got %d – body: %s", w.Code, w.Body.String())
	}

	w = chaosRequest(r, http.MethodGet, "/chaos/status", nil, sessID)
	if w.Code != http.StatusOK {
		t.Fatalf("status after remove: want 200, got %d – body: %s", w.Code, w.Body.String())
	}
	statusResp = map[string]interface{}{}
	if err := json.Unmarshal(w.Body.Bytes(), &statusResp); err != nil {
		t.Fatalf("status after remove not valid JSON: %v", err)
	}
	if active, _ := statusResp["active"].(bool); active {
		t.Fatalf("status after remove active = true, want false")
	}
	if stepsRun, _ := statusResp["stepsRun"].(float64); stepsRun != 0 {
		t.Fatalf("status after remove stepsRun = %v, want 0", stepsRun)
	}
	if _, ok := statusResp["loadedRunID"]; ok {
		t.Fatalf("status after remove should not include loadedRunID, got %v", statusResp["loadedRunID"])
	}

	// Export should no longer be available for the removed run state.
	w = chaosRequest(r, http.MethodPost, "/chaos/export", nil, sessID)
	if w.Code != http.StatusNotFound {
		t.Fatalf("export after remove: want 404, got %d – body: %s", w.Code, w.Body.String())
	}
}
